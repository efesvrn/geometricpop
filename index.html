<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Geometric Pop - Compact & Dense</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #121212; /* Biraz daha koyu arka plan */
            font-family: 'Fredoka', sans-serif;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 5;
        }

        .hud {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            color: #ecf0f1;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .score-box { font-size: 20px; }
        .score-val { font-size: 32px; font-weight: 600; color: #f1c40f; }
        .next-label { font-size: 12px; opacity: 0.7; margin-bottom: 5px; }
        #next-canvas { width: 40px; height: 40px; }

        #game-over-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(18, 18, 18, 0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            opacity: 0; transition: opacity 0.5s; pointer-events: none; z-index: 10;
        }
        #game-over-screen.active { opacity: 1; pointer-events: auto; }
        h1 { color: #ecf0f1; font-size: 48px; margin-bottom: 10px; }
        p { color: #95a5a6; font-size: 20px; margin-bottom: 40px; }
        button {
            background: #f1c40f; border: none; padding: 15px 40px;
            font-size: 24px; font-family: 'Fredoka', sans-serif; font-weight: 600;
            color: #2c3e50; border-radius: 50px; cursor: pointer;
            box-shadow: 0 10px 20px rgba(241, 196, 15, 0.3);
        }
        .tutorial {
            position: absolute; bottom: 120px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.4); font-size: 14px; pointer-events: none;
            animation: fadeOut 4s forwards 3s;
        }
        @keyframes fadeOut { to { opacity: 0; } }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud">
            <div class="score-box">SKOR<br><span class="score-val" id="score">0</span></div>
            <div class="next-shape-container" style="text-align: right;">
                <div class="next-label">SIRADAKİ</div>
                <canvas id="next-canvas" width="50" height="50"></canvas>
            </div>
        </div>
        <div class="tutorial">Nişan almak için sürükle, atmak için bırak</div>
    </div>

    <div id="game-over-screen">
        <h1>Oyun Bitti!</h1>
        <p>Son Skor: <span id="final-score">0</span></p>
        <button onclick="resetGame()">Tekrar Dene</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * GEOMETRIC POP - Compact & Dense Mode
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('next-canvas');
const nextCtx = nextCanvas.getContext('2d');
const scoreEl = document.getElementById('score');
const finalScoreEl = document.getElementById('final-score');
const gameOverScreen = document.getElementById('game-over-screen');

// --- Yapılandırma ---
const CONFIG = {
    cols: 15, // YENİ: Daha fazla sütun (Daha yoğun)
    rows: 22, // YENİ: Daha fazla satır
    colors: {
        circle: '#5DADE2', square: '#E74C3C', triangle: '#58D68D', pentagon: '#F1C40F'
    },
    shapes: ['circle', 'square', 'triangle', 'pentagon'],
    bg: '#121212', // Daha koyu arka plan
    bulletSpeed: 18, // Biraz daha hızlı mermi
    dropThreshold: 6,
    // Hardcore ayarları korundu
    visualSizeRatio: 0.5, 
    collisionThreshold: 0.55 
};

// --- Değişkenler ---
let width, height;
// Oyun alanı değişkenleri (Yeni)
let gameWidth, gameHeight, gameOffsetX, gameOffsetY, shooterY;

let tileRadius = 15; // Başlangıç değeri
let tileDiameter;
let rowHeight;
let grid = [];
let particles = [];
let bullet = null;
let currentShape = null;
let nextShapeType = null;
let animationId;
let score = 0;
let shotsFired = 0;
let isGameOver = false;
let aimAngle = -Math.PI / 2;
let isDragging = false;

// Ses Context
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx = new AudioContext();

// --- Başlatma ---
function init() {
    resize();
    window.addEventListener('resize', resize);
    
    canvas.addEventListener('mousedown', onPointerDown);
    canvas.addEventListener('mousemove', onPointerMove);
    window.addEventListener('mouseup', onPointerUp);
    canvas.addEventListener('touchstart', (e) => onPointerDown(e.touches[0]));
    canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onPointerMove(e.touches[0]); });
    window.addEventListener('touchend', onPointerUp);

    resetGame();
    loop();
}

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    // --- YENİ: Oyun Alanı Hesaplama ---
    // Ekranın %95'ini kullan ama çok geniş ekranlarda 600px ile sınırla
    gameWidth = Math.min(width * 0.95, 600); 
    
    // Grid hücresi boyutunu bu yeni gameWidth'e göre hesapla
    tileDiameter = gameWidth / CONFIG.cols;
    tileRadius = tileDiameter / 2;
    rowHeight = tileRadius * Math.sqrt(3);

    gameHeight = CONFIG.rows * rowHeight;

    // Oyun alanını ekranın ortasına hizalamak için ofsetler
    gameOffsetX = (width - gameWidth) / 2;
    gameOffsetY = height * 0.05 + 50; // Üstten biraz boşluk (HUD için)

    // Fırlatıcı konumu (Gridin bitiminden biraz aşağıda)
    shooterY = gameOffsetY + gameHeight + tileDiameter * 2;
    // Eğer fırlatıcı ekran dışına taşıyorsa, yukarı çek
    if (shooterY > height - 50) shooterY = height - 80;
}

function resetGame() {
    grid = [];
    particles = [];
    bullet = null;
    score = 0;
    shotsFired = 0;
    isGameOver = false;
    scoreEl.innerText = '0';
    gameOverScreen.classList.remove('active');

    // İlk 8 satırı doldur (Daha yoğun başlangıç)
    for (let r = 0; r < CONFIG.rows; r++) {
        grid[r] = [];
        for (let c = 0; c < CONFIG.cols; c++) {
            if (r < 8) {
                grid[r][c] = createTile(r, c, randomShape());
            } else {
                grid[r][c] = null;
            }
        }
    }
    currentShape = randomShape();
    nextShapeType = randomShape();
    drawNextShape();
}

// --- Yardımcı Fonksiyonlar ---
function randomShape() { return CONFIG.shapes[Math.floor(Math.random() * CONFIG.shapes.length)]; }

function createTile(r, c, type) {
    const pos = getGridPos(r, c);
    return { type: type, x: pos.x, y: pos.y, r: r, c: c, scale: 1 };
}

function getGridPos(r, c) {
    const rowOffset = (r % 2) * (tileDiameter / 2);
    // YENİ: gameOffsetX ve gameOffsetY eklendi
    return {
        x: gameOffsetX + c * tileDiameter + tileRadius + rowOffset,
        y: gameOffsetY + r * rowHeight + tileRadius
    };
}

// --- Oyun Döngüsü ---
function loop() {
    update();
    draw();
    if (!isGameOver) animationId = requestAnimationFrame(loop);
}

function update() {
    // Grid animasyonları
    for (let r = 0; r < CONFIG.rows; r++) {
        for (let c = 0; c < CONFIG.cols; c++) {
            if (grid[r][c]) {
                if (grid[r][c].scale > 1) grid[r][c].scale -= 0.05;
                if (grid[r][c].scale < 1) grid[r][c].scale += 0.05;
                if (Math.abs(grid[r][c].scale - 1) < 0.05) grid[r][c].scale = 1;
            }
        }
    }

    // Mermi Hareketi
    if (bullet) {
        bullet.x += bullet.vx;
        bullet.y += bullet.vy;

        let visualR = tileRadius * CONFIG.visualSizeRatio;
        
        // YENİ: Duvar sektirme artık gameOffsetX'e göre yapılıyor
        if (bullet.x - visualR < gameOffsetX) {
            bullet.x = gameOffsetX + visualR;
            bullet.vx *= -1;
        } else if (bullet.x + visualR > gameOffsetX + gameWidth) {
            bullet.x = gameOffsetX + gameWidth - visualR;
            bullet.vx *= -1;
        }
        // YENİ: Tavan çarpışması gameOffsetY'ye göre
        if (bullet.y - visualR < gameOffsetY) {
            snapBubble();
        }
        if (checkCollision()) snapBubble();
    }

    // Partiküller
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].x += particles[i].vx; particles[i].y += particles[i].vy; particles[i].life -= 0.05; particles[i].size *= 0.95;
        if (particles[i].life <= 0) particles.splice(i, 1);
    }
}

// --- Fizik & Mantık (Hardcore Korundu) ---
function checkCollision() {
    const minDist = tileDiameter * CONFIG.collisionThreshold;
    for (let r = 0; r < CONFIG.rows; r++) {
        for (let c = 0; c < CONFIG.cols; c++) {
            let tile = grid[r][c];
            if (tile) {
                let dx = bullet.x - tile.x; let dy = bullet.y - tile.y;
                if (Math.sqrt(dx*dx + dy*dy) < minDist) return true;
            }
        }
    }
    return false;
}

function snapBubble() {
    let bestDist = Infinity, bestR = -1, bestC = -1;
    for (let r = 0; r < CONFIG.rows; r++) {
        for (let c = 0; c < CONFIG.cols; c++) {
            if (!grid[r][c]) {
                let pos = getGridPos(r, c);
                let dist = (bullet.x - pos.x)**2 + (bullet.y - pos.y)**2;
                if (dist < bestDist) { bestDist = dist; bestR = r; bestC = c; }
            }
        }
    }
    if (bestR !== -1) {
        grid[bestR][bestC] = createTile(bestR, bestC, bullet.type);
        grid[bestR][bestC].scale = 1.3;
        playSound('pop', 600);
        getNeighbors(bestR, bestC).forEach(n => { if(grid[n.r][n.c]) grid[n.r][n.c].scale = 0.8; });
        bullet = null;
        resolveMatches(bestR, bestC);
        currentShape = nextShapeType; nextShapeType = randomShape(); drawNextShape();
        shotsFired++;
        if (shotsFired % CONFIG.dropThreshold === 0) addRow();
        checkGameOver();
    }
}

function resolveMatches(r, c) {
    let type = grid[r][c].type;
    let matchSet = new Set([`${r},${c}`]);
    let queue = [{r, c}];
    while(queue.length > 0) {
        let curr = queue.shift();
        getNeighbors(curr.r, curr.c).forEach(n => {
            if (grid[n.r][n.c] && grid[n.r][n.c].type === type && !matchSet.has(`${n.r},${n.c}`)) {
                matchSet.add(`${n.r},${n.c}`); queue.push(n);
            }
        });
    }
    if (matchSet.size >= 3) {
        matchSet.forEach(key => {
            let [mr, mc] = key.split(',').map(Number);
            createExplosion(grid[mr][mc].x, grid[mr][mc].y, grid[mr][mc].type); grid[mr][mc] = null; score += 10;
        });
        scoreEl.innerText = score; playSound('break', 200 + (matchSet.size * 50)); removeFloating();
    }
}

function removeFloating() {
    let visited = new Set(), queue = [];
    for (let c = 0; c < CONFIG.cols; c++) { if (grid[0][c]) { queue.push({r:0, c:c}); visited.add(`0,${c}`); } }
    while(queue.length > 0) {
        let curr = queue.shift();
        getNeighbors(curr.r, curr.c).forEach(n => {
            if (grid[n.r][n.c] && !visited.has(`${n.r},${n.c}`)) { visited.add(`${n.r},${n.c}`); queue.push(n); }
        });
    }
    for (let r = 0; r < CONFIG.rows; r++) {
        for (let c = 0; c < CONFIG.cols; c++) {
            if (grid[r][c] && !visited.has(`${r},${c}`)) {
                createExplosion(grid[r][c].x, grid[r][c].y, grid[r][c].type); grid[r][c] = null; score += 20;
            }
        }
    }
    scoreEl.innerText = score;
}

function getNeighbors(r, c) {
    let offsets = (r % 2 === 0) ? [[r, c-1], [r, c+1], [r-1, c-1], [r-1, c], [r+1, c-1], [r+1, c]] : [[r, c-1], [r, c+1], [r-1, c], [r-1, c+1], [r+1, c], [r+1, c+1]];
    return offsets.filter(p => p[0] >= 0 && p[0] < CONFIG.rows && p[1] >= 0 && p[1] < CONFIG.cols).map(p => ({r: p[0], c: p[1]}));
}

function addRow() {
    for (let r = CONFIG.rows - 1; r > 0; r--) {
        grid[r] = [...grid[r-1]];
        for(let c=0; c<CONFIG.cols; c++) { if(grid[r][c]) { grid[r][c].r = r; let pos = getGridPos(r, c); grid[r][c].x = pos.x; grid[r][c].y = pos.y; } }
    }
    grid[0] = []; for (let c = 0; c < CONFIG.cols; c++) grid[0][c] = createTile(0, c, randomShape());
}

function checkGameOver() {
    for (let c = 0; c < CONFIG.cols; c++) {
        // Oyun alanı bittiğinde (sondan 3. satıra gelince)
        if (grid[CONFIG.rows - 3][c]) { 
            isGameOver = true; finalScoreEl.innerText = score; gameOverScreen.classList.add('active'); playSound('gameover', 100); return;
        }
    }
}

// --- Grafik Çizimi ---
function draw() {
    ctx.fillStyle = CONFIG.bg;
    ctx.fillRect(0, 0, width, height);

    // YENİ: Oyun Alanı Sınırlarını Çiz (Opsiyonel, görsel rehber için)
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 2;
    ctx.strokeRect(gameOffsetX, gameOffsetY, gameWidth, gameHeight);

    // Grid Çizimi
    for (let r = 0; r < CONFIG.rows; r++) {
        for (let c = 0; c < CONFIG.cols; c++) {
            let tile = grid[r][c];
            if (tile) drawShape(ctx, tile.x, tile.y, tile.type, (tileRadius * CONFIG.visualSizeRatio) * tile.scale);
        }
    }

    // Mermi Çizimi
    if (bullet) drawShape(ctx, bullet.x, bullet.y, bullet.type, tileRadius * CONFIG.visualSizeRatio);

    // Fırlatıcı
    ctx.save();
    // YENİ: Fırlatıcı konumu shooterY'ye göre
    ctx.translate(width / 2, shooterY);
    if(!bullet) {
        ctx.beginPath(); ctx.setLineDash([5, 10]); ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(aimAngle) * 150, Math.sin(aimAngle) * 150);
        ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 2; ctx.stroke();
    }
    ctx.restore();

    if (!bullet && !isGameOver) drawShape(ctx, width / 2, shooterY, currentShape, tileRadius * CONFIG.visualSizeRatio);

    particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; });
}

function drawShape(context, x, y, type, size) {
    if (!size || size <= 0) size = 5;
    context.fillStyle = CONFIG.colors[type]; context.beginPath();
    if (type === 'circle') context.arc(x, y, size, 0, Math.PI * 2);
    else if (type === 'square') context.rect(x - size, y - size, size * 2, size * 2);
    else if (type === 'triangle') { context.moveTo(x, y - size); context.lineTo(x + size, y + size); context.lineTo(x - size, y + size); context.closePath(); }
    else if (type === 'pentagon') { for (let i = 0; i < 5; i++) { let angle = (i * 2 * Math.PI / 5) - Math.PI / 2; let px = x + size * Math.cos(angle); let py = y + size * Math.sin(angle); if (i === 0) context.moveTo(px, py); else context.lineTo(px, py); } context.closePath(); }
    context.shadowColor = 'rgba(0,0,0,0.3)'; context.shadowBlur = 4; context.shadowOffsetY = 3; context.fill(); context.shadowOffsetY = 0; context.shadowBlur = 0;
}

function drawNextShape() {
    nextCtx.clearRect(0,0,50,50);
    if(nextShapeType) drawShape(nextCtx, 25, 25, nextShapeType, 10);
}

// --- Efektler & Ses ---
function createExplosion(x, y, type) {
    const color = CONFIG.colors[type];
    for(let i=0; i<10; i++) particles.push({ x: x, y: y, vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12, size: Math.random()*4+2, color: color, life: 1.0 });
}

function playSound(type, freqStart) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator(); const gainNode = audioCtx.createGain();
    osc.connect(gainNode); gainNode.connect(audioCtx.destination);
    if (type === 'pop') { osc.type = 'sine'; osc.frequency.setValueAtTime(freqStart || 400, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1); gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1); osc.start(); osc.stop(audioCtx.currentTime + 0.1); }
    else if (type === 'shoot') { osc.type = 'triangle'; osc.frequency.setValueAtTime(200, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.15); gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.15); osc.start(); osc.stop(audioCtx.currentTime + 0.15); }
    else if (type === 'break') { osc.type = 'square'; osc.frequency.setValueAtTime(freqStart, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(freqStart * 1.5, audioCtx.currentTime + 0.1); gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2); osc.start(); osc.stop(audioCtx.currentTime + 0.2); }
    else if (type === 'gameover') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(300, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.8); gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.8); osc.start(); osc.stop(audioCtx.currentTime + 0.8); }
}

// --- Girdi ---
function onPointerDown(e) { if (isGameOver) return; isDragging = true; updateAim(e); }
function onPointerMove(e) { if (isDragging) updateAim(e); }
function onPointerUp(e) { if (isDragging && !bullet && !isGameOver) fire(); isDragging = false; }

function updateAim(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX || e.x) - rect.left; const y = (e.clientY || e.y) - rect.top;
    // YENİ: Nişan açısı shooterY'ye göre hesaplanıyor
    const dx = x - width / 2; const dy = y - shooterY;
    let angle = Math.atan2(dy, dx);
    if (angle > -0.2) angle = -0.2; if (angle < -Math.PI + 0.2) angle = -Math.PI + 0.2;
    aimAngle = angle;
}

function fire() {
    bullet = {
        x: width / 2,
        // YENİ: Mermi shooterY'den çıkıyor
        y: shooterY,
        vx: Math.cos(aimAngle) * CONFIG.bulletSpeed,
        vy: Math.sin(aimAngle) * CONFIG.bulletSpeed,
        type: currentShape
    };
    playSound('shoot');
}

init();
</script>
</body>
</html>
